Ananya Mathur (2020CS50416), Ishaan Govil (2020CS50497)

# INTRODUCTION
In this assignment to tackle the problem of misidentification of characters by the OCR system, we implement a search 
based algorithm which helps us to identify the misplaced characters in the words in a level wise fashion, based on how
much error is present in the word. The words would be replaced based on the cost function, on the basis whether the cost of 
the sentence is getting reduced after replacement.

# CORE IDEAS 
1. Precomputation of conf_matrix_inv - using the given conf_matrix in order to prevent exhaustive repeated search of each
entry of conf_matrix for each character replacement.
2. Local search/Hill climbing search -
3. Breadth first exhaustive search -
4. Breadth first random search -
5. Change backtracking - Some words might be replaced because of the local optimality that we are checking, as well as because
of the initial mistakes present in the complete sentence, so a backtracking of Change is essential to check if the original words
were better for the overall sentence. 
6. Iterative Deepening

# Algorithm
1. Initially we precompute an inverse configuration matrix, computed using the given conf_matrix which stores all the characters
that can come in place of the misplaced character, assuming that character is misplaced.
2. Then, we begin in a level wise manner, based on the no. of errors a word might have. We first begin by invoking the function singular_change_exhaustive. This function locally explores possible one character replacements in words to find the optimal state.
3. Next, the function singular_change_complete is invoked. This function checks for global optimality of one character replaced words in the current best solution.
4. The function double_change_exhaustive is invoked next, which performs exhaustive depth first search for each word of the sentence and stores optimal solution similar to local search.
5. singular_change_exhaustive is invoked again, to perform local search in the current optimal sentence.
6. The function backtrack_change is invoked. This function backtracks the changed words to check if a word has been mistakenly replaced during local optimisation.
7. Then triple_quad_change_random is called. This function is non exhaustive breadth first random search, which explores states based on a certain heuristic of largest three sentence cost in the current state. It explores both three character and four character replacement states based on the heuristic and randomisation.
8. Finally penta_change_random is called, which is also non exhaustive breadth first random search, based on the same heuristic and checks for five character replacements randomly to generate a more optimal state.
